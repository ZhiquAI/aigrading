# AI 智能批改助手 - 代码审查报告 (v0.1.0)

**审查日期**: 2026-02-06
**审查范围**: `aigradingbackend` (后端), `aigradingfrontend` (前端 Chrome 扩展)
**状态**: ✅ 核心功能稳定，🛡️ 安全性待增强，🚀 性能表现优异

---

## 1. 总体架构概览

系统采用 **Next.js 14 (App Router)** + **React 18** + **Prisma ORM** 的全栈架构。
- **后端**: 负责 AI 模型中转、配额管理、JWT 认证及批改记录同步。
- **前端**: Chrome 扩展形式，集成 Zustand 状态管理、图片压缩处理及多服务路由。

---

## 2. 后端核心模块审查 (`aigradingbackend`)

### 2.1 AI 批改流水线 (`/api/ai/grade`)
- **实现**: 建立了 `GPTSAPI (GPT-4o)` -> `智谱 GLM-4` -> `Gemini` 的三级降级机制。
- **优点**: 极大地提升了系统的容灾能力，有效应对单一 API 供应商停服或限流风险。
- **风险**: 批改记录的存储采用异步 `.then()` 方式，虽不阻塞主线程，但无法保证记录的 100% 成功持久化。

### 2.2 安全与身份验证
- **机制**: 已实现 JWT 双令牌机制（Access 15min / Refresh 7days）。
- **配额控制**: 基于 `Device-ID` 和 `Activation Code` 双轨制，逻辑清晰。
- **限流**: 使用内存滑动窗口算法，配置了不同等级的 API 访问频率限制。
- **改进点**: 内存限流在多实例部署（如负载均衡）下无法共享状态，建议后续引入 Redis。

### 2.3 数据库模型
- **ORM**: Prisma 使用得当，Schema 定义了清晰的用户、激活码、设备配额和批改记录关系。

---

## 3. 前端核心模块审查 (`aigradingfrontend`)

### 3.1 状态管理 (`useAppStore.ts`)
- **技术栈**: Zustand + Persist。
- **亮点**: 
  - 完善的本地/远程同步逻辑。
  - 自动修复/迁移旧版数据字段（`points` 兼容 `answerPoints`）。
  - 处理了计算属性在 Zustand 中的 getter 陷阱。

### 3.2 AI 路由层 (`ai-router.ts`)
- **实现**: 统一了多模型调用接口，支持 JSON Mode 和多图片输入。
- **解耦**: 业务代码通过 `callAI` 调用，无需关心底层供应商差异。

### 3.3 图片优化策略 (`proxyService.ts`)
- **性能**: 实现 `compressImageBase64`，通过灰度化、尺寸限制和 JPEG 压缩，预计减少 **70-90%** 的传输体积。
- **效果**: 显著提升了网络不佳环境下的批改体验。

---

## 4. 关键改进建议

### 🚨 优先级：高 (影响稳定性与安全)
1. **统一 JWT 接入**: 前端 `APIClient` 目前仍部分使用硬编码的 header，需接入后端的 JWT 刷新流程，防止登录失效。
2. **数据模型归一化**: 彻底消除 `points` 和 `answerPoints` 的歧义，从 DB 到 UI 统一使用 `answerPoints`。
3. **关键操作同步化**: 后端 `deductQuota` 和 `createRecord` 应使用事务或 `await` 确保强一致性。

### 🟡 优先级：中 (优化体验)
1. **统一拦截器**: 在前端引入 `axios` 或封装 `fetch` 拦截器，统一处理 401 (过期) 和 429 (限流) 响应。
2. **错误处理增强**: 完善 AI 服务的超时重试机制，特别是在移动网络波动的场景。

---

## 5. 接下来值得探究的 3 个问题

1. **Token 自动续期**: 是否需要我为前端实现自动刷新 Access Token 的拦截器逻辑？
2. **Redis 集成**: 如果计划在生产环境进行多实例部署，是否需要现在引入 Redis 存储速率限制数据？
3. **批改记录深度分析**: 是否需要为教师端设计基于 ECharts 的班级成绩趋势分析报表？

---
**审核员**: Gemini CLI Assistant
**项目负责人**: 用户 (Tech Partner)
